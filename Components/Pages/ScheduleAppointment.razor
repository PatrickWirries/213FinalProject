@page "/schedule-appointment"
@rendermode InteractiveServer
@using Data
@using _213FinalProject.Models
@inject NavigationManager Navigation
@inject _213FinalProjectContext context
@inject AuthService AuthService

<PageTitle>Schedule Appointment</PageTitle>

<h1>Schedule Appointment</h1>


@* --=-- Needs to be removed once logging in is implemented --=-- *@

<div class="mb-3">
    <label class="form-label">Customer</label>
    <InputSelect class="form-select" @bind-Value="model.CustomerID">
        <option value="0">-- Select Customer --</option>
        @foreach (var c in customers)
        {
            <option value="@c.UserID">@c.FullName (@c.Email)</option>
        }
    </InputSelect>
</div>
@* --=-- Needs to be removed once logging in is implemented --=-- *@


@* --=-- Service Selection --=-- *@
<div class="mb-3">
    <label class="form-label">Service</label>
    <div>
        @foreach (var s in filteredServices)
        {
            bool disabled = selectedEmployeeId.HasValue && !employeeServiceMap[selectedEmployeeId.Value].Contains(s.ServiceID);
            <button class="btn @(selectedServiceId == s.ServiceID ? "btn-success" : "btn-outline-primary") me-2 mb-2"
                    disabled="@disabled"
                    @onclick="() => ToggleService(s.ServiceID)">
                @s.Name (@s.DurationMinutes min) - @s.BasePrice.ToString("C")
            </button>
        }
    </div>
</div>
@* --=-- Service Selection --=-- *@



@* --=-- Employee Selection --=-- *@
<div class="mb-3">
    <label class="form-label">Employee</label>
    <div>
        @foreach (var e in filteredEmployees)
        {
            bool disabled = selectedServiceId.HasValue && !serviceEmployeeMap[selectedServiceId.Value].Contains(e.UserID);
            <button class="btn @(selectedEmployeeId == e.UserID ? "btn-success" : "btn-outline-primary") me-2 mb-2"
                    disabled="@disabled"
                    @onclick="() => ToggleEmployee(e.UserID)">
                @e.FullName
            </button>
        }
    </div>
</div>
@* --=-- Employee Selection --=-- *@



@* --=-- Date Selection --=--*@
<div class="mb-3 date-selector">
    <label class="form-label">Date</label>
    <InputDate @bind-Value="selectedDate" class="form-control" Min="@DateTime.Today" />
</div>

@* --=-- Date Selection --=--*@



@* --=-- Time Selection --=-- *@
<div class="mb-3">
    <label class="form-label">Timeslots</label>

    @if (selectedDate == null || selectedServiceId == null || selectedEmployeeId == null)
        { <div class="text-muted"> Select date, service, and employee to view availability. </div> }

    else
    {
        <div>
            @foreach (var time in GetAvailableTimeSlots())
            {
                <button class="btn @(model.ScheduledTime == time ? "btn-success" : "btn-outline-primary") me-2 mb-2"
                    @onclick="() => SelectTime(time)">
                    @time.ToString("hh:mm tt")
                </button>
            }
        </div>
    }
</div>
@* --=-- Time Selection --=-- *@




@* --=-- Price Display --=-- *@
<div class="mb-3 price-display">
    <label class="form-label">Price</label>
    <InputText class="form-control" @bind-Value="displayPrice" readonly />
</div>
@* --=-- Price Display --=-- *@


<button class="btn btn-primary btn-submit" @onclick="SubmitAppointment">Schedule</button>



@if (!string.IsNullOrEmpty(successMessage))
{ <div class="alert alert-success mt-3">@successMessage</div> }

@code {
    private static readonly TimeOnly BusinessOpen = new TimeOnly(9, 0);
    private static readonly TimeOnly BusinessClose = new TimeOnly(17, 0);
    private const int SlotMinutes = 30;


    private Appointment model = new Appointment();
    private string? successMessage;
    private string displayPrice = "N/A";
    private List<Customer> customers = new List<Customer>();
    private List<Service> services = new List<Service>();
    private List<ServicePerforming> performingEmployees = new List<ServicePerforming>();

  

    

    private List<Service> filteredServices => services;
    private List<ServicePerforming> filteredEmployees => performingEmployees;

    // selected ids
    private int? selectedServiceId = null;
    private int? selectedEmployeeId = null;
    private DateOnly? selectedDate = DateOnly.FromDateTime(DateTime.Now);


    // mapping for filtering
    private Dictionary<int, List<int>> serviceEmployeeMap;
    private Dictionary<int, List<int>> employeeServiceMap;





    protected override void OnInitialized()

    {

        // Build mappings
        serviceEmployeeMap = new Dictionary<int, List<int>>();
        employeeServiceMap = new Dictionary<int, List<int>>();

        customers = context.Customer.ToList();
        services = context.Service.ToList();
        performingEmployees = context.Employee.OfType<ServicePerforming>().ToList();

        foreach (var sp in context.ServicePerformingEmployeeService)
        {
            if (!serviceEmployeeMap.ContainsKey(sp.ServiceID))
            { serviceEmployeeMap[sp.ServiceID] = new List<int>(); }

            serviceEmployeeMap[sp.ServiceID].Add(sp.EmployeeID);


            if (!employeeServiceMap.ContainsKey(sp.EmployeeID))
            { employeeServiceMap[sp.EmployeeID] = new List<int>(); }
            employeeServiceMap[sp.EmployeeID].Add(sp.ServiceID);
        }
    }

    private void ToggleService(int serviceId)
    {
        if (selectedServiceId == serviceId)
        {
            selectedServiceId = null;
            model.ServiceID = 0;
            model.Price = 0;
            displayPrice = "N/A";
        }
        else
        {
            selectedServiceId = serviceId;
            model.ServiceID = serviceId;
            var s = services.First(x => x.ServiceID == serviceId);
            model.Price = s.BasePrice;
            displayPrice = s.BasePrice.ToString("C");

            // if currently selected employee cannot perform this service, unselect
            if (selectedEmployeeId.HasValue && !serviceEmployeeMap[serviceId].Contains(selectedEmployeeId.Value))
            {
                selectedEmployeeId = null;
                model.EmployeeID = 0;
            }
        }
    }

    private void ToggleEmployee(int employeeId)
    {
        if (selectedEmployeeId == employeeId)
        {
            selectedEmployeeId = null;
            model.EmployeeID = 0;
        }
        else
        {
            selectedEmployeeId = employeeId;
            model.EmployeeID = employeeId;

            // if currently selected service is not supported by this employee, unselect
            if (selectedServiceId.HasValue && !employeeServiceMap[employeeId].Contains(selectedServiceId.Value))
            {
                selectedServiceId = null;
                model.ServiceID = 0;
                model.Price = 0;
                displayPrice = "$0.00";
            }
        }
    }

    private List<TimeOnly> GetAvailableTimeSlots()
    {
        if (!selectedDate.HasValue || !selectedEmployeeId.HasValue || !selectedServiceId.HasValue)
            return new();

        var service = services.First(s => s.ServiceID == selectedServiceId.Value);
        int duration = service.DurationMinutes;

        var reserved = context.Appointment
            .Where(a =>
                a.EmployeeID == selectedEmployeeId &&
                a.ScheduledDate == selectedDate)
            .ToList();

        var slots = new List<TimeOnly>();
        var current = BusinessOpen;

        while (current.AddMinutes(duration) <= BusinessClose)
        {
            bool overlaps = reserved.Any(a =>
            {
                var reservedStart = a.ScheduledTime;
                var reservedEnd = a.ScheduledTime.AddMinutes(a.Duration);

                var slotEnd = current.AddMinutes(duration);

                return current < reservedEnd && slotEnd > reservedStart;
            });

            if (!overlaps)
                slots.Add(current);

            current = current.AddMinutes(SlotMinutes);
        }

        return slots;
    }

    private void SelectTime(TimeOnly time)
    {
        model.ScheduledTime = time;
        model.ScheduledDate = selectedDate!.Value;
    }


    private void SubmitAppointment()
    {
        if (model.CustomerID    == 0    ||
            model.ServiceID     == 0    ||
            model.EmployeeID    == 0    ||
            selectedDate        == null ||
            model.ScheduledTime == default)
        {
            successMessage = "Please complete all selections.";
            return;
        }


        // Save appointment (simulate)
        successMessage = $"Appointment scheduled: Customer {model.CustomerID}, Service {model.ServiceID}, Employee {model.EmployeeID}, Price {model.Price:C}";
    }
    private bool _checkedAuth;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender || _checkedAuth)
            return;

        _checkedAuth = true;

        if (!await AuthService.IsLoggedInAsync())
        {
            Navigation.NavigateTo("/LoginUser", forceLoad: true);
        }
        StateHasChanged();
    }
}
